---
title: "Lorelogram: describing correlation structure in binary data"
date: "`r format(Sys.time(), '%d %B %Y')`"
bibliography: C:/Users/Fabiola/Documents/Bibtex/Lorelogram Vignette.bib
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Lorelogram: describing correlation structure in binary data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r, include = FALSE}
knitr::opts_chunk$set(fig.align = "center", fig.width = 6, fig.height = 4, 
  collapse = TRUE,
  comment = "#>"
)
```



# Table of contents
1. [Introduction](#introduction)
2. [How to apply the lorelogram](#paragraph1)
    1. [Data format](#subparagraph1)
3. [Another paragraph](#paragraph2)




# 1. Introduction <a name="introduction"></a>

The __lorelogram__ package provides functions to explore and graphically describe correlation structures in binary data. The package is available on GitHub and can be downloaded in R (@RCoreTeam2018) via:

```{r load pkg, warning = FALSE, message = FALSE, results = 'hide'}
if (!require("devtools")) install.packages("devtools", repos = "http://cran.us.r-project.org", dependencies = "Imports")
devtools::install_github("FabiolaIannarilli/lorelogram", auth_token = "69451dbc8b643e18d5e25b488e0a485b59a93512") 
library(lorelogram)
```

The lorelogram is a very usufel tool to identify dependency structure in binary data, guide data aggregation, explore the effect of covariates on the correlation in the data. It can also be applied to explore the dependency in a certain dataset at different spatial or temporal scales (e.g., camera trap data analyzed at the hour- or minute-scale). See @Iannarilli for examples of applications. The method has been developed by @Heagerty1998 and is based on pairwise log-odds ratio. For more information on the method and on applications in ecological studies see @Iannarilli.

Here we focused on guiding new users on how to apply the lorelogram to their own dataset. We provide step-by-step examples, and compare the efficiency of our `lorelogram` function with other functions for calculating the lorelogram available in R (@RCoreTeam2018). 

The main function in the __lorelogram__ package is called `lorelogram`. This function allows users to calculate log-odds ratio at each spatial or temporal lag up to a maximum interval between subsequent observations. It also returns a plot of these values, the lorelogram plot, that graphically represents how the correlation changes with the increase of the spatial or temporal interval between observations. 

We use the data associated with the package to provide a first example. This dataset consists of detection/nondetection data of gray fox (_Urocyon cinereoargenteus_) collected using camera traps at 100 locations in Northern Minnesota during fall 2016. We provided details on the structure of this data in the [Data format] section whereas further data on the sampling protocol are available at \url{https://drive.google.com/drive/folders/12cx59tZvPndOWqH7TG6XKGPFd6HyBjMR?usp=sharing}. We just load the data and apply the `lorelogram` function. 

```{r ex1}
data("GrayFox_Hour")
lorelogram(GrayFox_Hour, max_lag = 30)
```

The `lorelogram` function returns a data frame containing the estimated average log-odds ratio values and associate 95% confidence interval at each lag (defined by the parameter \code{max_lag}), and a plot of the estimates. The data frame component of the output can be assigned to an object that can be later used as the argument for the function `lor_plot`. This second function allows users to save the plot as a jpeg file in a directory of their choice and have more control on plot features. For example, using `lor_plot` we can assign a title to the plot, change the default label for the x axis and the linetype, specify the color of the 95% confidence interval, the  distance among breaks in the x axis, and the range of the y axis.

```{r ex2}
LORs <- lorelogram(GrayFox_Hour, plot_LOR = FALSE)
lor_plot(LORs, save_LOR_plot = FALSE, title = "My first lorelogram", x_axis_title = "Lag (Hour)", colour="red", linetype = "dashed", x_break = 24, ylim = c(-2,5))
```

# 2. How to apply the lorelogram

In this section we are going to illustrate how to apply the `lorelogram` function to new datasets, briefly explore the differences between empirical and model-based lorelogram, provide some guidance on when and why might be convinient to bin the data, and show how to determine time to independence using a derivate-based approach.   

## 2.1 Data format <a name="data format"></a>

The `lorelogram` function accepts both wide and long data format. Wide format data should contain a sampling unit identifier in the first column and the binary data in the following columns, one for each sampling replicates. Each row should represent a sampling unit. In the wide format, it is important to organize the data into the columns from first to last sampling occasion (with data for the first replicate contained in the second column, second replicate in third column, and so on) because the order of the columns will be then be used by the function to define the spatial or temporal interval between two outcomes at the same sampling unit.

```{r ex3}
GrayFox_Hour[24:28, 1:31]
```
In this subset of the GrayFox_Hour data each column from the second to the last reports the binary data: the dectection of the species during a certain hour is coded as 1, 0 otherwise. The data showed here have been collected at five sites during the first 30 hours of sampling. Note as the columns are ordered from hour 1 (column 'o1') to hour 30 (column 'o30'). NAs indicate occasions in which the camera trap at a certain site was no yet active (e.g., sites 6A and 6C); at site 6B the camera trap was deployed and actived at the 25th hour since the start of the whole period of study. 

In the long format data, information are organized in three columns, that must be organized in the order described here. The first column contains the sampling unit identifier, the second contains numeric values indicating the time or space of each replicate, the last column contains the binary outcome.

```{r ex4}
data("GrayFox_Hour_long")
GrayFox_Hour_long[2501:2520,]
```

These data are a subset of the same gray fox data organized in the long format and show the detection/nondetection outcomes (column 'y') at twenty different camera sites (column 'id') at the 26th hour of sampling (column 'time'). 

Sites in which there are no detection (i.e. no 1s) for the whole sampling period are automatically removed because they do not contain information on correlation among detections. The `lorelogram` function handles missing values (i.e. NAs) in the data; for each sampling units, these values will be removed before creating the pairwise detection histories at the different intervals.

## 2.2 Interpreting the lorelogram

Lorelogram plots provide a graphical description of how the correlation in the data changes with the increase of the interval between sampling occasions. Their interpretation vary based on the resolution of the data (e.g., hour- versus minute-scale), and the context in which it is applied (e.g., spatial versus temporal dependency). Here we provide some general guidance on how to interpret the lorelogram. 

## 2.3 How the `lorelogram` function works 

The lorelogram requires binary data at each sampling unit (e.g. a camera site) summarized at the scale of interest (e.g. by day, hour, or minute). The `lorelogram` function first remove sampling units with no detection and convert the detection/non-detection data from wide to long format if necessary (Fig. 1, step A). Then, for each sampling unit, it pairs outcomes at different replicates based on all the possible combinations of lags ≤\code(max_lag) unit-lag apart (Fig. 1, step B). The combinations are obtained using the function `combinations` in package __arrangements__ @Lai2018, whereas the pairing is performed using the `nest` and `unnest` functions in __tidyverse__ @Hadley2017. For each discrete interval (i.e. 1 through \code(max_lag)), the function tabulated the number of occurrence of each pairwise detection history ‘11’, ‘10’, ‘01’, or ‘00’ at each sampling units, and then pool data across units if more then one unit has been sampled (Fig. 1, step C). In the empirical lorelogram, these values are used to calculate the average log-odds ratio value at each interval as: $LOR=\log{\frac{n_{11}n_{00}}{n_{01}n_{01}}}$ . The 95% confidence interval at each lag is calculated as: $CI^{95\%} = LOR\pm1.96*\sqrt{\frac{1}{n_{11}}+\frac{1}{n_{00}}+\frac{1}{n_{10}}+\frac{1}{n_{11}}}$.
![Figure 1. Conceptual diagram of the formatting process undergoing in the `lorelogram` function. Example of how camera trap data are converted from detection histories to the counts necessary to calculate the lorelogram values (i.e. pairwise log-odds ratios). Detection histories are first converted from wide to long format (A), then the fucntion compile the outcomes $y_{i}$ and $y_{j}$ as pairwise detections based on all the possible pairwise combinations of time _i_ and _j_ within the maximum time lag ($\Delta t$) considered (B). Finally, for each value of $\Delta t$, we counted the number of 00, 01, 10, 00 detection histories, respectively (C), across all values of _i_ and _j_ that were $\Delta t$ units apart.](C:/Users/Fabiola/Documents/PhD Matherial/LORELOGRAM_TEMPORAL DEPENDENCY/Writing/fig Data formatting_cropped.jpg){width=50%}

## 2.4 Computational challenges

The most demanding step in terms of computational effort is creating the pairwise detection histories at the different lags (step B in Fig. 1). This step can be quite demanding when estimating log-odds ratios in large datasets because of the large amount of potential pairwise combinations of replications (e.g. $y_{t_{1}},y_{t_{2}}$. For example, a camera trapping period of one week corresponds to 10 080 potential detection events at the minute scale (i.e. 7 days x 24 hours x 60 minutes) for each camera deployed. This results in over 50 million possible combinations of $t_{i},t_{j}$. Even limiting combinations to only those ≤60 minutes apart, decreases this number to just around 603 000 combinations for each camera site. However, describing the detection structure up to 1 hour is sufficient to identify short-term dependency in camera trap data and keeps the computational time and RAM required within acceptable limits. The  `lorelogram` function required ~30 minutes on a regular Windows machine (8 GB; Intel® Core™ i7-4500U CPU @ 1.80GHz 2.40GHz) to compile the lorelogram for time lags between 0 and 60 minutes using 62 days of camera trap data collected from 31 camera sites (see figure 5a in @Iannarilli).


# References
